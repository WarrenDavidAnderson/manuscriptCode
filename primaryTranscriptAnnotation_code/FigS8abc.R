
# note. Fig S8d can be generated using FigS8d.R 

setwd("/media/wa3j/Seagate2/Documents/PRO/adipogenesis/package/SM/degpca")

library(dplyr)
library(ggplot2)
library(DESeq2)
library(LSD)
library(VennDiagram)

#######################################################################################
## acquire data
## note. differential expression data were generated by pro_time_deg_ge.R and pro_time_deg_tu.R
## for largest interval gene annotations and inferred annotations, respectively
#######################################################################################

# out = list(deg=deg, deseq_obj=deseq_obj)
load("LRTres_pro_TU.RData")
deg.tu = out$deg
deseq.tu = out$deseq_obj
rm(out)

load("LRTres_pro_GE.RData")
deg.ge = out$deg
deseq.ge = out$deseq_obj
rm(out)

# TU annotation (generated using the vignette for primaryTranscriptAnnotation)
tu.ann = read.table("TU_20190731.bed",stringsAsFactors=F,header=F)
names(tu.ann) = c("chr","start","end","gene","xy","strand")

# gene annotation (generated using the vignette for primaryTranscriptAnnotation)
# see section 5: largest.interval.bed = get.largest.interval(bed=gencode.transcript)
ge.ann = read.table("largest.interval.bed",stringsAsFactors=F,header=F)
names(ge.ann) = c("chr","start","end","gene","xy","strand")

bigWig.path = paste0("/media/wa3j/Seagate2/Documents/PRO/adipogenesis",
                     "/July2018/bigWig_20181001/all_pro_sample_bigWig")

############################################################
## key analysis parameters
############################################################

# significance thresh for LRT
sig.thresh = 0.001

#######################################################################################
## get genes in both data sets
#######################################################################################

# lrt results
res.tu = results(deg.tu) %>% as.data.frame(stringsAsFactors=F)
res.ge = results(deg.ge) %>% as.data.frame(stringsAsFactors=F)

# gene ids
get.id = function(input=NULL){
  out = sapply(input,function(x){
    strsplit(x,"_")[[1]][2]
  })
  return(out)
}
ids.tu = get.id( rownames(res.tu) )
ids.ge = get.id( rownames(res.ge) )

# matching genes, indices, deg res
match.inds = function(match.ids=NULL, all.ids=NULL){
  inds = sapply(match.ids,function(x){
    which(all.ids == x)
  })
  return(inds)
}
match.ids = ids.tu[ids.tu %in% ids.ge]
ind.tu = match.inds(match.ids=match.ids, all.ids=ids.tu)
ind.ge = match.inds(match.ids=match.ids, all.ids=ids.ge)
res.tu.match = res.tu[ind.tu,]
res.ge.match = res.ge[ind.ge,]
all(ids.tu[ind.tu] == ids.ge[ind.ge])
res.tu.match = res.tu.match %>% mutate(gene = ids.tu[ind.tu])
res.ge.match = res.ge.match %>% mutate(gene = ids.ge[ind.ge])


#######################################################################################
## compare deg results with plots
## Fig S8a,b
#######################################################################################

# correlate fdrs
x = -log10( res.ge.match$padj )
y = -log10( res.tu.match$padj )
rem1 = which(is.na(x)==T | x=="Inf")
rem2 = which(is.na(y)==T | y=="Inf")
rem = union(rem1,rem2)
x = x[-rem]
y = y[-rem]

pdf("degcomp.pdf")
par(mfrow=c(2,2))

ylab = expression(paste("tu, -log" ["10"], " (FDR)"))
xlab = expression(paste("gene, -log" ["10"], " (FDR)"))
heatscatter(x, y, add.contour=F, nlevels=5, xlab=xlab, ylab=ylab)
abline(0,1,lwd=3)

lim = c(0,50)
heatscatter(x, y, add.contour=F, nlevels=5, xlim=lim, ylim=lim, xlab=xlab, ylab=ylab)
abline(0,1,lwd=3)

#######################################################################################
## compare deg results with venn diagrams
## Fig S8c
#######################################################################################

# filter for significance
res.ge.match.sig = res.ge.match %>% filter(padj < sig.thresh)
res.tu.match.sig = res.tu.match %>% filter(padj < sig.thresh)

# separate out different categories
ge.not.tu = res.ge.match.sig$gene[!(res.ge.match.sig$gene %in% res.tu.match.sig$gene)]
tu.not.ge = res.tu.match.sig$gene[!(res.tu.match.sig$gene %in% res.ge.match.sig$gene)]
ge.in.tu = res.ge.match.sig$gene[res.ge.match.sig$gene %in% res.tu.match.sig$gene]
tu.in.ge = res.tu.match.sig$gene[res.tu.match.sig$gene %in% res.ge.match.sig$gene]

# for browser
match.inds2 = function(match.ids=NULL, all.ids=NULL){
  inds = sapply(match.ids,function(x){
    grep(x,all.ids)
  })
  return(unlist(inds))
}
coords.tu = rownames(res.tu)
coords.ge = rownames(res.ge)
ind.tu = match.inds2(match.ids=tu.not.ge, all.ids=coords.tu)
ind.ge = match.inds2(match.ids=ge.not.tu, all.ids=coords.ge)

res.tu[ind.tu,]
res.ge[ind.ge,]

# venn diagram
length(ge.not.tu)
length(tu.not.ge)
length(ge.in.tu)
length(tu.in.ge)

a1 = length(tu.not.ge) + length(tu.in.ge)
a2 = length(ge.not.tu) + length(tu.in.ge)
a3 = length(tu.in.ge)
  
grid.newpage()
draw.pairwise.venn(area1 = a1, area2 = a2, cross.area = a3, 
                   category = c("sig tus","sig genes"))

dev.off()


#######################################################################################
## ggplot heatscatter - create legend
#######################################################################################

library(MASS)
library(ggplot2)
library(ggthemes)
library(LSD)

DF <- data.frame(x,y)

# Calculate 2d density over a grid
dens <- kde2d(x,y)

# create a new data frame of that 2d density grid
gr <- data.frame(with(dens, expand.grid(x,y)), as.vector(dens$z))
names(gr) <- c("xgr", "ygr", "zgr")

# Fit a model
mod <- loess(zgr~xgr*ygr, data=gr)

# Apply the model to the original data to estimate density at that point
DF$pointdens <- predict(mod, newdata=data.frame(xgr=x, ygr=y))

# Draw plot with scale
p <- ggplot(DF, aes(x=x,y=y, color=pointdens)) + theme_base() + scale_colour_gradientn(colours = colorpalette('heat', 10))
p <- p + geom_point() + geom_density2d(color='black')
print(p)

